Lesson 10 Notes

Detailed notes:
- Hello everyone. Uh, so my name is Raphael Townshend.
- I'm one of the head TAs for this class. This week Andrew is traveling and my advisor is still dealing with medical issues.
- So I'm going to be giving today's lecture. Um, you heard from my wonderful co-head TA Anand a couple of weeks ago.
- And so today, we're gonna be going over decision trees and various ensemble methods.
- Uh, so these might seem a bit like disparate topics at first, but really decision trees are, sort of, a classical example model class to use with various ensembling methods.
- We're gonna get into a little bit why in a bit, but just to give you guys an overview of what the outlines can be.
- We're first gonna go over decision trees, then we're gonna go over general ensembling methods and then go specifically into bagging random forests and boosting.
- Okay. So let's get started. So first let's cover some decision trees.
- Okay. So last week, Andrew was covering SVNs that are, sort of, one of the classical linear models and,
- sort of, brought to a close a lot of discussion of those linear models. And so today we gonna be getting to decision trees which is really
- one of our first examples of a non-linear model. And so to motivate these guys let me give you guys an example.
- Okay. So I'm Canadian, I really like to ski. So I'm gonna motivate it using that.
- So pretend you have a classifier that given a time and a location tells you whether or not you can ski,
- so it's a binary classifier saying yes or no. And so you have, you can imagine, a graph like this,
- and on the x-axis we're gonna have time in months, so counting from the start.
- So starting at 1 for January to 12 for December, and then on the y-axis we're gonna use latitude in degrees, okay?
- And so for those of you who might have forgotten what latitude is, it's basically at positive 90 degrees you're at the North Pole,
- at negative 90 degrees you're at the South Pole. So positive 90, negative 90,
- 0 being the Equator and it's, sort of, your location along the north-south axis.
- Okay. So given this, if you might recall, the winter in the Northern Hemisphere generally happens in the early months of the year.
- So you might see that you can ski in these early months over here and it has some positive data points, and then in the later months,
- right, and then in the middle, you can't really ski.
- Versus in the Southern Hemisphere, it's basically flipped, where you can not ski in the early months.
- You can ski during the May, June, July, August time period,
- and then you can't ski in the earlier months, and then the equator in general is just not great for skiing that's the reason I don't live there,
- and so you just have a bunch of negatives here. Okay. And so when you look at a data set like this,
- you've sort of got these separate regions that you're looking at, right? And you sort of want to isolate out those regions of positive examples.
- If you had a linear classifier, you'd sort of be hard-pressed to come up with any sort of decision boundary that would separate this reasonably.
- Now you could think okay, maybe you have an SVM or something, you've come up with a kernel that could perh- perhaps project this into a higher feature space that would make it linearly separable,
- but it turns out that with decision trees, you have a very natural way to do this.
- So to sort of make clear exactly what we want to do with decision trees, is we wanna sort of partition the space into individual regions.
- So we sort of wanna isolate out these, like, positive examples, for example. In general this problem is fairly intractable just coming up with the optimal regions.
- But how we do with decision trees is we do it in this basically greedy,
- top-down, recursive manner,
- and this is going to be recursive partitioning.
- Okay? And so it's- basically it's top-down because we're starting with the overall region and we wanna slowly partition it up, okay?
- And then it's greedy because at each step we wanna pick the best partition possible. Okay. So let's actually try and work out intuitively what a decision tree would do, okay?
- So what we do is we start with the overall space and the tree is basically gonna play 20 Questions with this space.
- Okay. So like for example, one question it might ask is, if we have the data coming in like this, is,
- is the latitude greater than 30 degrees, okay?
- And that would involve, sort of, cutting the space like this, for example, okay?
- And then we'd have a yes or a no.
- And so starting from, like, the most general space now we have partitioned the overall space into two separate spaces using this, this question.
- Okay. And this is where the recursive part comes in now, because now that you've sort of split the space into two,
- you can then sort of treat each individual space as a new problem to ask a new question about.
- So for example now that you've asked this latitude greater than 30 question, you could then ask something like,
- month less than like March or something like that.
- All right, and that would give you a yes or no. And what that works out to effectively,
- is that now you've taken this upper space here and divided it up into these two separate regions like this.
- And so you could imagine how through asking these recursive questions over and over again,
- you could start splitting up the entire space into your individual regions like this.
- Okay, and so to make this a little bit more formal, what we're looking for is,
- we're looking for, sort of, the split function, okay? So you can, sort of, define a region. So you have a region and let's call that region R_p in this case for R parent, okay?
- And we're looking for, looking for a split S_p,
- such that you have an S_p, you can, sort of, write out this S_p function as a function of j,t.
- Okay, where we saw you- j is which feature number and T is the threshold you're using.
- And so you can, sort of, write this out formally as, sort of, you're outputting a tuple, where on the one hand you have a set X where you
- have the x j- the jth feature of x is less than the threshold,
- and you have Xs element of R-p, since we're only partitioning that parent region.
- And then the second set is literally the same thing, except it's just those that are greater than t. And so we can refer
- to each one of these as R_1 and R_2.
- Any questions so far? No? Okay. So we,
- sort of, define now how we would, sort of, do this. We're trying to, like, greedily pick these peaks that are partitioning our input space and the splits are,
- sort of, defined by which feature you're looking at and the threshold that you're applying to that feature.
- Uh, sort of a natural question to ask now is, is how do you choose these splits,
- right? And so I sort of gave this intuitive explanation, that really what you're trying to do is you're trying to isolate out
- the space of positives and negatives in this case. And so what is useful to define is a loss on a region, okay?
- So define your loss L on R,
- loss on R. And
- so for now let's define our loss as something fairly obvious, is your misclassification loss.
- It's how many examples in your region you get wrong. And so assuming that you have, uh,
- given C classes total,
- you can define P hat c
- to be the proportion
- of examples in R
- that are of class c. [NOISE]
- And so now that we've got this definition, where we had this p hat c of telling us the proportion of examples that we've gotten that case,
- you can try to define the loss of any region as loss,
- let's call it misclassification, it's just 1 minus max over c of p hat c, okay?
- And so the reasoning behind this is basically you can say that for any region that you've subdivided generally,
- what you'll want to do is predict the most common class there, which is just the maximum p hat c, right?
- And so then all the remaining probability just gets thrown onto misclassification errors, okay?
- And so then once we do this, we want to basically pick- now that we have a loss defined,
- we want to, um, pick a split that decreases the loss as much as possible.
- So you recall I've defined this region, R_parent, and then these two children regions R_1 and R_2.
- And you basically want to reduce that loss as much as possible. So you want to, um,
- basically minimize loss,
- R_parent minus loss of R_1 plus loss of R_2.
- And so this is sort of your parent loss,
- this is your children loss.
- Okay. And since you're picking- and basically what you're minimizing over in some case is this j, t that we
- defined over here since this split is really what is gonna define our two children regions, right.
- And what you'll notice is that the loss of the parent doesn't really matter in this case because that's already defined.
- So really all you're trying to do is minimize this negative sum of losses of your children, okay?
- So let's move to the next board here. [NOISE]
- So I started to find this misclassification loss. Let's get a little bit into actually why misclassification loss isn't actually the right loss to use for this problem, so,
- okay? And so for a simple example, let's pretend- So I've sort of drawn out a tree like this,
- Let's pretend that instead we have another setup here where we're coming into a decision node.
- And at this point we have 900 positives and 100 negatives, okay?
- So this is sort of a misclassification loss, of 100 in this case because you'd predict the most common class and end up with 100 misclassified examples.
- All right, and so this would be your region R_p right now, right? And so then you can split it into these two other regions, right?
- Say R_1 and R_2.
- And say that what you've achieved now is you have the 700 positive,
- 100 negatives on this side versus, uh, 200 positives and 0 negatives on this side, okay?
- Now, this seems like a pretty good split since you're getting out some more examples.
- But what you can see is that, if you just drew the same thing again, right, R_p with 900 and 100,
- split split, and say in this case, instead,
- you've got 400 positives over here, 100 negatives, and 500 positives and 0 negatives.
- So most people would argue that this bright decision boundary is better than the left one because you're basically isolating out even more positives in this case.
- However, if you're just looking at your misclassification loss, it turns out that on this left one here,
- let's call this R_1 and R_2 versus this right one, Let's call this R_1 prime, R_2 prime, okay?
- So your loss of R_1 plus R_2,
- on this left case it's just 100 plus 0. All right, so it's just 100.
- And then on the right side here, it's actually still just the same, right?
- And in fact, if you'd look at the original loss of your parent it's also just 100, right?
- So you haven't really according to this loss metric changed anything at all. And so that sort of brings up one problem with the misclassification loss is that,
- it's not really sensitive enough, okay? So like instead what we can do is we can define this cross-entropy loss, okay?
- So which we'll define as L_cross.
- Let me just write this out here.
- And so really what you're doing is you're just summing over the classes and it's the probability- that the proportion of elements in that class
- times the log of the proportion in that class. And how you can think of this is, It's sort of this concept that we borrow from information theory,
- which is sort of like the number of bits you need to communicate to tell someone who already knows what the probabilities are what class you are looking at.
- And so that sounds like a mouthful but really you can sort of think of it intuitively as, if someone already knows the probabilities,
- like say it's a 100% chance that it is of one class, then you don't need to communicate anything to tell
- them exactly which class it is because it's obvious that it is that one class versus if you have a fairly even split then you'd need to communicate
- a lot more information to tell someone exactly what class you were in.
- Any questions so far? Yeah? [inaudible].
- The R_1, R_2 for the parent class? [inaudible].
- For this case here? Yeah, yeah, so, um, for that case there so you see that, er,
- I'll try and reach up there, but so it's like say like R_p was your start region, right? You could say it's the overall region, right?
- And then R_1 would be all the points above this latitude 30 line. And R_2 would be all the points below the latitude 30 line.
- Yeah, yeah? [inaudible].
- Yeah. So the question is, when you're trying to minimize this loss here, is it the same as maximizing the,
- the children loss, and since, er - no, uh, ah, let's see, of maximizing the children loss.
- And yeah, it turns out it doesn't really matter, which, um, which way you put it. It just- basically, you're trying to either minimize the loss of
- the children or maximize the gain in information, basically. [inaudible].
- Yeah. Let's see. Yeah, you're right. That should actually be a max. Let me fix that really quick.
- Because you start with your parent loss, and then you're subtracting out your children's loss,
- and so the amount left, let's see, the higher this loss is- yeah. So you really want to maximize this guy.
- Makes sense, everyone? Thanks for that.
- Okay, so I've sort of given this like, hand-wavy- Oh, sure, what's up? [inaudible].
- So that would be log-based. The question is, for the cross-entropy loss, is it log base 2 or log base c? It's log base 2.
- Okay, here, I can write that out. Yep.
- [inaudible]. Oh, sorry, I didn't quite hear that.
- [inaudible].
- Okay. Um, so the question is can- uh, what is the proportion that are correct versus incorrect
- for these two examples we've worked through here? Um, and so, yeah- basically, what we're starting with is,
- we're starting with we have 900/100, 900 positives and 100 negatives. All right, so you can imagine that if you just stopped at this point, right,
- you would just cla- classify everything as positive, right, and so you get 100 negatives incorrect.
- Does that make sense? Because this is 900 positives and 100 negatives. So if you just stopped here and just tried to classify,
- given this whole region R_p, you would end up getting 10% of your examples wrong, right?
- In this case, we're sort of talking- we're not talking about percentages, we're talking about absolute number of examples that we've gotten wrong,
- but you can also definitely talk in terms of percentages instead. And then down here, once you've split it,
- right, now you've got these two subregions, right? And for- on this, on this left one here,
- you still have more positives than negatives, right? So you're still gonna classify positive in this leaf, right?
- And you're still gonna classify positive in this leaf, too, because they- they're both majority class,
- or the positives are still the majority class there. And in this case, since you have 0 negatives, you're not gonna make any errors in your classification,
- whereas in this case here, it's still going to make 100 errors. And so what I'm saying is that, at this level, so if we just look above this line at R_p,
- right, you're making 100 mistakes, and then below this line you're still making 100 mistakes.
- So what I'm saying is that, that the loss in this case is not very informative. [inaudible].
- Um, so this, this p-hat- okay, I'm being a little bit loose with terminology with the notation here,
- but the p-hat in this case is a proportion, okay? But you can also easily- basically,
- it's like whether you're normalizing the whole thing or not. Yeah. Okay. So I've
- sort of given this a bit handwavy explanation as to why misclassification loss versus cross-entropy loss might be better or worse.
- Um, we can actually get a fairly good intuition for why this is the case by looking at it from a sort of geometric perspective.
- So pretend now that you have this, this plot, okay?
- And what you're plotting here is- pretend you have a binary classification problem, okay? So you have just- is it positive class or negative class, okay?
- And so you can sort of represent, say p-hat, as like the proportion of positives in your set, okay?
- And what you've got plotted up here is your loss. Okay. For cross-entropy loss,
- where your curve is gonna end up looking like is, is gonna end up looking like this strictly concave curve like this, okay?
- And what you can do is you can sort of look at where your children versus your parent would fall on this curve.
- So say that you have two children, okay? You have one up here, so like let's call this LR1.
- And you have one down here, LR2, okay?
- And say that you have an equal number of examples in both R1 and R2, so they're equally weighted.
- If you take- when you're looking at the overall loss between the two, right, that's really just the average of the two.
- So you can draw a line between these two, and the midpoint turns out to be the average of your two losses.
- So this is LR1 plus LR2 divided by 2.
- That's for this guy, okay? And what you can notice is that, in fact,
- the loss of the parent node is actually just this point projected upwards here,
- so this would be your LR parent. And this difference right here,
- this difference, is sort of your change in loss.
- Does this makes sense? Any questions?
- Okay. So we have this- just to recap, okay. So we have- say, we have two children regions, right?
- And they have different probabilities of positive examples occurring, right? They sort of would fall- one would fall on this point on the curve, and say,
- the other one falls on this point on the curve, then the average of the two losses sort of falls on the midpoint between these two original losses.
- And if you look at the parent, it's really just halfway between on the x-axis,
- and you can project up towards for that as well, and you end up with the loss of R_parent. What's up? [inaudible].
- Okay. So what we're looking at here is we're looking at the cross entropy loss. So you've got this function here, this L cross entropy right,
- and that's in terms of p-hat c's, right? In this case here, we're just assuming that we have two classes, okay?
- So what we're doing is we're just modifying the p-hat c, we're, we're changing that on the x-axis and then we're looking at what
- the response of the overall loss function is on the y-axis. And so what I just did here is for any- this curve just represents for any p-hat c,
- what the cross entropy loss would look like. Okay. And so we can come back to this, for example, right?
- And if we look at this parent here right, this guy has a 10%, right? It's sort of like p-hat,
- p-hat for this guy is 0.1, it's 10% basically or,
- or I guess no, in this case, would be 0.9 sorry. And then versus here, in these two cases, right,
- your p-hat, in this case, is 1 since you've got them all right, all right, and then, in this case,
- it's 0.8, okay? So you can sort of see since these are equal, there's the same number of examples in both of these,
- the p-hat of the parent is just the average of the p-hat's of the children. Okay. And so that's how we can sort of take this LR_parent,
- this LR_parent is just halfway, if we projected this down, all right. Let me just erase this little bit here.
- If we projected this down like this,
- we'd see that this- that this point here is the midpoint.
- Okay. Um, but then when you're actually averaging the two losses after you've done the split,
- then you can basically just, you're just taking the average loss right? You're just summing LR1 plus
- LR2 and if you're taking the average then you're dividing by two, and what you can do is you can just draw the line and take the midpoint of this line instead. Yeah.
- [inaudible]. Yeah. [inaudible]
- Yeah. Exactly. So yeah really any- if there- it's a good point. The question was if you have an uneven split,
- uh what would that look like on this curve, right? And so at this point, I've been making the math easy by
- just saying there's an even split but really if there was a slightly uneven split you- the average would just be any point along this line that you've drawn.
- As you can see the whole thing is strictly concave so any point along that line is going to lie below the original loss curve for the parent.
- So you're basically, as long as you're not picking the exact same points on the probability curve and not making any gain at all in your split,
- you're gonna gain some amount of information through this split.
- Okay. Now, this was the cross-entropy loss, right?
- If instead, we look at the misclassification loss over here,
- let's draw this one instead.
- What we can see, in this case, if you draw it is that it's in fact really this pyramid kind of shape where
- it's just linear and then flips over once you start classifying the other side. And if you did the same argument here where we had LR1 and LR2,
- and then you drew a line between them, all right, that's basically just still the loss curve, and so,
- in this case, like your midpoint would be the same point as your parent. So your loss of R_parent, in this case,
- would equal your loss of R1 plus loss of R2 divided by 2.
- All right. And so in this case, you can- there's even now according to the cross entropy formulation,
- you do have a gain in information and intuitively we do see a gain in information over here. For the misclassification loss, since it's not very sensitive,
- if you end up with points on the same side of the curve, then you actually don't see any sort of information gain based on this kind of representation.
- And so there's actually a couple, I, I presented the cross entropy loss here. There's also the Gini loss which is another one,
- which people just write out as, as the sum over your classes p-hat c times one minus p-hat c,
- okay, and it turns out that this curve also looks very similar to this original cross entropy curve.
- And what you'll see is that actually most curves that are successfully used for de- decision splits,
- look basically like the strictly concave function.
- Okay. So that's where it covers a lot of the criteria we use for splits.
- Um, let's look at some extensions for decision trees.
- Actually, I'm going to keep this guy.
- Okay. So, so far I've been talking about decision trees for classification.
- You could also imagine having decision trees for regression, and people generally call these regression trees, okay.
- So taking the ski example again let's pretend that instead of now predicting whether or not you can ski,
- you're predicting the amount of snowfall you would expect in that area around that time. Um, so like let's- I'm just gonna say it's like inches of snowfall I guess or something,
- per like day or something and just like maybe have some values up here.
- Some high value because you're- it's winter over there, it's mostly 0s over here because there's summer,
- and then you have some more high values over here, and then you have 0s along the equator again.
- 0s, southern hemisphere over our winter,
- and then more 0s like this. And you can sort of see how you would do just the exact same thing.
- You still want to isolate out regions and sort of increase like the purity of those regions. So you could still create like your trees like this,
- all right, and split out like this for example. And what you do when you get to one of your leaves
- is instead of just predicting a majority class, what you can do is predict the mean of the values left.
- So you're predicting, predict y hat where, well for Rm.
- So pretend you have a region Rm, you're predicting y hat of m which is the sum of all the indices in Rm,
- Y i minus y hat m, and you want the squared loss and then you can sort of I guess,
- in this case, you want to normalize by the overall cardinality of Rm or how many points you have in Rm.
- And so in this case, basically all you've done is you've switched your loss function or, no sorry that's wrong.
- [LAUGHTER] This is actually- I got a little bit ahead of myself. This is actually just- the,
- the mean value would just be this, in this case, right? It's just your summing all the values within your region.
- So in this case, 7, 9, 8, 10, and then just taking the average of that. Um, but so then what you do,
- what I was starting to write out there was actually really the, the loss that you would use, in this case, right, which is your squared loss, okay?
- So like we'll just call that L squared which, in this case,
- would be equal to Y i minus
- y hat m squared over R m. That's what I started to write over there.
- But in this case, right, you have your mean prediction and then your loss in this case, is how far off your mean prediction is from the overall predictions,
- in this case. Yep.
- So in terms of [inaudible].
- So that's a really good question. The question was uh, how do you actually search for your splits,
- how do you actually solve the optimization problem of finding these splits? And it turns out that you can actually basically brute force it very efficiently.
- I'm going to get into sot of the details of how you do that shortly, but it turns out that you can just go through everything
- fairly quickly. Um, I'll get into that. I think that's in a couple of sections from now,
- yeah. Any other questions? Okay. So this is,
- uh, for regression trees, right? It turns out that, um, another useful extension that,
- that you don't really get for other learning algorithms is that you can also deal with, uh, categorical variables fairly easily.
- And basically, for this case, you could imagine that instead of having your latitude in degrees,
- you could just have three categories right? You could have something like, uh,
- this is the northern hemisphere, this is the equator,
- and this is the southern hemisphere, okay? And then you could ask questions instead of the sort,
- like that initial question we had before, where it was latitude greater than 30. Your question could instead be is,
- is- I guess this would be, is location in northern hemisphere?
- Right. And you can have basically any sort of subset- you could ask me question about any sort of subset of the categories you're looking at.
- Right? So in this case Northern, you would still- this question would still split out this top part from these bottom pieces here.
- One thing to be careful about though is that if you have q categories,
- then you have- I mean, you basically are considering every single possible subset of these categories.
- So that's 2 to the q possible splits.
- And so in general, you don't want to deal with too many categories because this will become quickly intractable to look through that many possible examples.
- It turns out that in certain very specific cases, you can still deal with a lot of categories.
- One such case is for binary classification where then you can just- the math is a little
- bit complicated for this one but you can basically sort your categories by how many positive examples are in each category,
- and then just take that as like a sorted order then search through that linearly, and it turns out that that yields to an optimal solution.
- So decision trees, we can use them for regression, we can also use them for categorical variables.
- Um, one thing that I've not gotten into is that, you can imagine that in the limit if you grew your tree without ever stopping,
- you could end up just having a separate region for every single data point that you have. Um, so that's really- you could consider that probably
- over fitting if you ran it all the way to that completion, right? So you can sort of see that decision trees are fairly high variance models.
- So one thing that we're interested in doing is regularizing these high variance models.
- And generally, how people have solved this problem is through a number of heuristics, okay? So one such heuristic is that if you hit a certain minimum leaf size,
- you stop splitting that leaf, okay? So for example in this case if you've hit like you only have
- four examples left in this leaf, then you just stop. Another one is you can enforce a maximum depth,
- and sort of a related one in this case is a max number of nodes.
- And then a fourth very tempting one I've got to say to use is you say,
- a minimum decrease in loss, right?
- I say this one's tempting because it's generally not actually a good idea to use this minimum decrease in loss 1.
- You can think about that, by thinking that if you have any sort of higher-order interactions between your variables, um,
- you might have to ask one question that is not very optimal, or doesn't give you that much of an increase in loss,
- and then your follow-up question combined with that first question might give you a much better increase. And you can sort of see that in this case,
- where the initial latitude questions doesn't really give us that much of a gain. We sort of split some positive and negatives,
- but the combination of the latitude question plus the time question really nails down what we want.
- And if we were looking at it purely from the minimum decrease in loss perspective, we might stop too early and miss that entirely.
- And so a better way to do this kind of loss decrease is instead you grow out your full tree,
- and then you prune it backwards instead. So you grow out the whole thing and then you check which nodes to prune out.
- Pruning. And how you generally do this, is you, you take it- you have a validation set that you use this with,
- and you evaluate what your misclassification error is on your validation set. If for each example that you might remove for each leaf that you might remove.
- So you would use misclassification in
- this case with a validation set.
- Any questions? Yeah? The minimum decrease in loss.
- The minimum decrease in loss? So, um, yeah of course. Uh, so you'll recall that before I was talking about sort of this RP,
- this loss of R_parent versus loss of R_1 plus loss of R_2. All right, so when we're- I had written out a maximization basically,
- um, oh to be clear, the question is, can you explain a little bit more clearly what this minimum decrease in loss means?
- And so you have your loss of R_1 and R_2 versus your loss of R_parent, right? So the split before the split, right,
- you have your loss before split.
- You have the loss of R_parent, and then after split,
- you have loss of R_1 plus loss of R_2.
- Yeah. And if, if this decrease between your loss of R_parent to your loss of your children is not great enough,
- you might be tempted to say, "Okay, that question didn't really gain us anything, and so therefore we will not actually use that question."
- But what I'm saying is that sometimes you have to ask multiple questions, right? You have to ask sort of sub-optimal questions first to get to the really good questions,
- especially if you have sort of interaction between your variables, if there is some amount of correlation between your variables.
- Okay. So we talked about regularization.
- I said that we would get to run time, let's actually just go up here again.
- [NOISE] So let's cover that really quickly.
- [NOISE]
- Okay. So it'll be useful to define a couple of numbers at this point. So say you have n examples.
- [NOISE] You have f features,
- and finally, you have, uh, d- let's say the depth of your tree is d, okay.
- All right. So you've gra- you, you have n examples that you trained on you- with the each of f features and your resulting tree has depth d. So at test time,
- your run-time is basically just your depth d, right? [NOISE] It's just o of d,
- right? Which is your depth. And typically, though not in all cases, um,
- d is sort of about- is less than the log of your number of examples.
- And you can sort of think about this as if you have a fairly balanced tree right, you'll end up sort of evenly splitting out all the examples and sort of recursively like
- doing these binary splits and so you'll be splitting it at the log of that n. Okay. So at test-time you've generally got it pretty quick.
- Uh, at train time,
- um, you have each point.
- So if you return back to this example, you'll see that each point, right, once you've done a split only belongs to
- the left or right of that split afterwards. All right. So it's sort of like, like this point right here, once you've split here will only ever be part of this region,
- will never be considered on the other side, on the right-hand side of that split. All right.
- So if your, if your tree is of depth d, each point,
- each point is part
- of Od nodes.
- Okay. And then at each node, you can actually work out that the cost of evaluating that point
- for- at training time is actually just proportional to the number of features f.
- I won't get too much into the details of why this is, but you can consider that if you're doing binary features, for example,
- where each feature is just yes or no of some sort, then you only have to consider, if you have f features total,
- you only have to consider, um, f possible splits. So that's why the cost in that case would be f,
- and then if it was instead a, uh, quantitative feature, I mentioned briefly that you could sort
- the overall features and then scan through them linearly, um, and that also ends up being asymptotically O of f to do that.
- Okay. So each point is at most O of d nodes, and then the cost of point at each node is O of f and you have n points total.
- So the total cost is really just,
- is just O of nfd, like this.
- It turns out that this is actually surprisingly fast, uh,
- especially if you consider that n times f is just the size of your original design matrix,
- right or your data matrix, all right. Your data matrix is
- of size n times f,
- right, and then you're only- your, your runtime is going through the data matrix that most depth times,
- and since depth is log of n, that turns out to be or generally bounded by log of n, you have generally, a fairly,
- fast training time as well. Any questions about runtime? [NOISE] Okay.
- So I've been talking a lot about the good sides of decision trees right, they seem pretty nice so far.
- However, there are a number of downsides too. Um, and one big one is that it doesn't have additive structure to it.
- And so let me explain a little bit what that means.
- Okay. So let's say now we have an example and you have just two features again,
- so x1 and x2, and you ca- say you define a line, okay,
- just running through the middle defined by x1 equals x2. And all the points above this line are positive,
- and all the points below it are negative. Now, if you have a simple linear model like logistic regression,
- you'll have no issue with this kind of setup. But for a decision tree, [LAUGHTER] basically,
- you'd have to ask a lot of questions that even somewhat approximate this line. Like, what you can try is you're going to say okay let's split it this way,
- and maybe we can do a split this way and then now I split here, maybe something like this,
- and basically something like that, right? Even here you- so you've asked a lot of questions and you've only gotten
- a very rough approximation of the actual line that you've drawn in this case. And so decision trees do have a lot of issues with these kind of structures
- where the v- the features are interacting additively with one another.
- Okay. So to recap so far, since we've covered a number of different things about decision trees,
- there's a number of pu- pluses and minuses to decision trees. Okay. So on the plus side, they're actually,
- I think this is an important point is that they're actually pretty easy to explain, right? If you're explaining what a decision tree is to like a non-technical person,
- it's fairly obvious you're like okay you have this tree, you're just playing 20 Questions with your data and letting it co- come up with one question at a time.
- There are also interpretable, you can just draw out the tree especially for shorter trees to see exactly what it's doing.
- It can deal with categorical variables,
- and it's generally pretty fast.
- However, on the negative side, one that I alluded to is that they're
- fairly high variance models and so are oftentimes prone to overfitting your data.
- They're bad at additive structure.
- And then finally they have, because in large part because of these first two,
- they generally have fairly low predictive accuracy. [NOISE] I know what you guys are thinking,
- I just spent all this time talking about decision trees and then I tell you guys they actually sort of suck. So why did I actually cover decision trees?
- And the answer is that in fact you can make decision trees a lot better through ensembling.
- And a lot of the methods, for example at the leading methods in Kaggle these days are actually built on ensembles of decision trees,
- and they really provide an ideal sort of model framework to look at, through which we can examine a lot of these different ensembling methods.
- Any questions about decision trees before I move on? [NOISE] Yeah?
- [inaudible].
- I don't think that's strictly- Okay. So the question is for the cross-entropy loss,
- does the log need to be base 2? And the answer is I'm pretty sure that it's not very relevant in this case,
- I'm not 100% sure about that but I'm pretty sure that the base of the log of that makes, it's cross entropy loss actually initially came out of like information theory,
- we have like computer bits and you're transmitting bits. So it's useful to think in terms of bits of information that you can transmit,
- which is why it came up as log base 2 in the initial formulation. [NOISE]
- Okay. So now let's talk about ensembling.
- Okay. So why does ensembling help? At some level, you can sort of think back to your basic, uh, statistics.
- So say you have, um, you have XIs, XIs, which are random variables.
- I'll sometimes write this as just RV, um,
- that are independent and identically distributed.
- And so probably a lot of you are familiar with this already or you can call this IID, okay.
- Now say that your variance of one of these variables is Sigma squared.
- Then what you can show is that the variance of the mean of many of these variables.
- So let's- of many of these random variables or written alternatively,
- 1 over N sum over I to the XI is equal to Sigma
- squared over N. And so each independent variable you factor in is
- decreasing the variance of your model, all right? And so the thought is that if you can factor in a number of independent sources,
- you can slowly decrease your variance. Okay, so, uh, so that- though this is
- a little bit simplistic of a way of looking at this, because really all these different things are factoring together have some amount of correlation with each other.
- And so this independence assumption is oftentimes not correct. So if instead,
- you drop the independence assumption.
- So now your variables are just ID, right?
- Okay. And say we can characterize what the correlation between any two XIs is and we can write that down as Rho. So Xi.
- Then you can actually write out the variance of your mean as
- Rho Sigma squared- Sigma squared,
- plus 1 minus Rho over M or- no, N Sigma squared, okay?
- And so you can sort of see that if your correlation- if they're fully correlated, then your- this term will drop to 0 and
- that you'll just have Sigma squared again because adding a bunch of fully correlated variables is just gonna give you the original variable's variance versus if they're
- completely decorrelated then this term drops to 0 and you just end up with Sigma squared over N which gives you the initial,
- uh, independent identically distributed equation.
- And so in this case, really what you wanna do- the name of the game is, you wanna have as many different models that you're
- factoring as possible to increase this N which drives this term down. And then on the other hand, you also want to make sure
- those models are as decorrelated as possible so that your Rho goes down and this first term goes down as well, okay?
- And so this gives rise to a number of different ways to ensemble.
- And one way you could think about doing this is you just use different algorithms, right?
- This is actually what a lot of people in Kaggle, for example, will do, is they'll just take a neural network or Random Forest, an SVM,
- average them all together and generally that actually works pretty well but- then you sort of have to
- spend your time implementing all these separate algorithms which is oftentimes not the most efficient use of your time.
- Another one that people would like to do is just use different training sets.
- Okay. And again, in this case, like you probably spent a lot of effort collecting your initial training set,
- you don't want your- like machine learning person to just come and recommend to you that, just go collect a whole second training set
- or something like that to improve your performance. Like that's generally not the most helpful recommendation, okay?
- And so then, what we're gonna cover now are these two other methods that we use to do ensembling. And one of them is called bagging,
- which is sort of trying to approximate having different training sets.
- We'll get into that quickly. And then you also have boosting.
- And just so that you guys will have a little bit of context, we're gonna be using decision trees to talk a lot about these models;
- and so bagging, you might have heard of random forests, that's a variant of bagging for decision trees.
- And then for boosting, you might have heard of things like AdaBoost,
- or XGBoost, which are variants of boosting for decision trees.
- Okay, so that sort of covers at a high level what we would wanna do. These first two are very nice because they're sort of would give us a much
- more like independently correlated- or less correlated variables. But generally, we're- we end up doing these latter two
- 1:00:06
- because we don't want to collect new training sets or train entirely new algorithms. Okay, so let's cover bagging first.
- 1:00:20
- Okay, so bagging really stands for this thing. It's called bootstrap aggregation, okay?
- 1:00:27
- Um, and so- first,
- 1:00:41
- let's just break down this term. So bootstrap, what that is, is it's typically this method used in statistics to measure
- 1:00:47
- the uncertainty of your estimate, okay? And so what- what is useful to define in this case for when you're talking about bagging
- 1:00:55
- is you can say that you have a true population P, okay?
- 1:01:07
- And your training set- training set S is sampled from P, right?
- 1:01:18
- So you just start drawing a bunch of examples from P and that's what forms your training set at some level. And so ideally, like for example,
- 1:01:25
- this different training set's approach. What you do is, you just draw S1, S2, S3, S4, and then train your model in each one of those separately.
- 1:01:32
- Unfortunately, you generally don't have the time to do that. And so what ba- what Bootstrapping does,
- 1:01:39
- is you assume basically that your population is your training sample, okay?
- 1:01:48
- So you assume that your population is your training sample. And so now that you have this S is approximating your P,
- 1:01:54
- then you can draw new samples from your population by just drawing samples from S instead, okay?
- 1:02:01
- So you have bootstrap samples, is what they're called.
- 1:02:11
- Z sampled from S. And so how that works is you basically just take your train- your- your training sample, okay?
- 1:02:20
- Say it's of like cardinality N or something. And you just sample N times from S and this is important,
- 1:02:26
- you do it with replacement. Because they're pretending that this is the population, and so doing it with replacement sort of makes that assumption
- 1:02:33
- hold that you're sampling from it as a population.
- 1:02:38
- Okay, so that's bootstrapping. So you generate all these different bootstrap samples Z on your- from your training set.
- 1:02:47
- And what you can do is you can take your model and train it on all these separate bootstrap samples, and then you can sort of look at the variability in
- 1:02:54
- the predictions that your model ends up making based on these different bootstrap samples. And that gives you sort of a measure of uncertainty.
- 1:03:01
- I'm not gonna go into too much detail now because that's not actually what we're gonna use Bootstrapping for. What we want to use bootstrapping for is we wanna aggregate these two Bootstrap samples.
- 1:03:11
- And so at a very high level, what that means is we're gonna take a bunch of Bootstrap samples, train separate models on each and then average their outputs, okay?
- 1:03:22
- So let's make that a little bit more formal. [NOISE]
- 1:03:46
- So you have bootstrap samples
- 1:03:59
- Z_1 through Z_M say, okay, capital M. That's just say how many bootstrap samples you're going to take.
- 1:04:07
- Okay, you train [NOISE] a model,
- 1:04:16
- G_M, okay, on Z_M, okay?
- 1:04:25
- Then all you're doing is you're just defining this new sort of meta model.
- 1:04:30
- I'm not putting a subscript on this one to show that it's a meta model, T of M, which is just the sum of your predictions of your individual models,
- 1:04:43
- divided by the total number of models you have, all right? And this is just me writing out what I was sort of talking about right up there for bagging.
- 1:04:54
- If you're taking these bootstrap samples and then you're training separate models, and then you're just aggregating them all together to get this bagging approach.
- 1:05:06
- So if we just do a little bit of analysis from the bias-variance perspective on this,
- 1:05:12
- we can sort of see why this kind of thing might work. [NOISE]
- 1:05:28
- And so you recall we had this equation up here, right? The va- variance of the mean is rho sigma squared,
- 1:05:33
- plus 1 minus rho, over n of sigma squared. So let me just write that out here. [NOISE]
- 1:05:49
- And in this case, our M is actually really uh, just the number of bootstrap samples. So we'll just use big M in this case.
- 1:05:57
- And what you're doing is by taking these bootstrap samples, you're sort of decorrelating the models you're training.
- 1:06:03
- Your bootstrapping [NOISE] is
- 1:06:11
- driving down [NOISE] rho.
- 1:06:17
- Okay. And so by driving this down,
- 1:06:22
- you're sort of making this term get smaller and smaller. And then your question might be okay, what about this term here? And it turns out that basically you can take as many bootstrap samples as you want,
- 1:06:32
- and that will slowly drive down- it increases M and drive down this second term. And it turns out that one nice thing about bootstrapping,
- 1:06:40
- is that increasing the number of bootstrap models in your training, doesn't actually cause you to overfit anymore than you were beforehand.
- 1:06:49
- Because all you're doing, is you're driving down this term here. So more M [NOISE] and it's just less in variance.
- 1:06:59
- [NOISE] All you're doing is driving down the second term as much
- 1:07:06
- as possible when you're getting more and more bootstrap samples. So generally, it only improves performance. And so generally what people will do is they'll sample
- 1:07:12
- more and more models until they see that their error stops going down. Because that means they basically eliminated this term over here.
- 1:07:19
- So this seems kinda nice, right? You're decreasing the variance, where is the trade-off coming in? Oh, there is a question there.
- 1:07:27
- [inaudible].
- 1:07:33
- Yeah, there's definitely a bound, right? Because um, I'm not going to define one formally right now.
- 1:07:39
- Oh, the question is can you define a bound on how much you decrease rho by? Uh, I'm not- yeah,
- 1:07:45
- so there's definitely a lower bound [NOISE] or, oh yeah, a lower bound on how far you can decrease rho.
- 1:07:52
- Basically it comes down to your bootstrap samples are still fairly highly correlated with one another, all right.
- 1:07:58
- Because they're still just drawing it from the same sample set S. Really, your Z is gonna end up containing about two- each Z is going to contain
- 1:08:05
- about two thirds of S. And so your Zs are still gonna be fairly highly correlated with each other. And no, I don't have a formal equation to write down as to
- 1:08:12
- exactly how much that decreases rho by, or how much that bounds rho by, you can sort of see intuitively that there is a bound there and that you can't just
- 1:08:20
- magically decrease rho all the way down to 0 and achieve 0 variance. [NOISE] All right.
- 1:08:29
- So saying that you decrease variance, that seems very nice. One issue that comes up with, with uh,
- 1:08:36
- bootstrapping is that in fact you're actually slightly increasing the bias of your models when you're doing this.
- 1:08:41
- And the reasoning for that [NOISE] is because of
- 1:08:52
- this sub-sampling that I was talking about here. Each one of your Zs is now about two-thirds of the original S. So you're training on less data um,
- 1:09:00
- and so your models are becoming slightly less uh, you know, complex and so that increases your bias in this case. Yes.
- 1:09:07
- [inaudible]
- 1:09:14
- Yeah, for sure. Um, so the question is, can you explain the difference between
- 1:09:20
- a random variable and an algorithm in this case, right? And so you could sorta- at a, at a very high level,
- 1:09:25
- you can think of an algorithm as a classifier- as a function that's taking in some data and making a prediction.
- 1:09:31
- Right? And if you sort of see those- that whole setup as sort of like, the probability, the algorithm is
- 1:09:37
- giving some sort of output in the probabilistic perspective, you can sort of see the algorithm as like a random variable in the case- in this case.
- 1:09:45
- Sort of like, you're basically considering, sort of the space of possible predictions that
- 1:09:51
- your algorithm can make and that you can sort of see as a distribution of possible predictions
- 1:09:56
- and that you can approximate that as a random variable. I mean it is a random variable at some level, because it's sort of like based on what's training sample you end up with,
- 1:10:05
- your predictions of your output model are gonna change. And so since you're sampling sort of these random samples from your population set,
- 1:10:13
- you can consider your algorithm as sort of based on that random sample and therefore a random variable itself.
- 1:10:21
- Okay. So yeah, your bias is slightly increased because [NOISE] of random subsampling,
- 1:10:32
- [NOISE] but generally,
- 1:10:41
- the decrease in variance that you get from doing this, is much larger than the slight increase in bias you get from,
- 1:10:47
- from doing this randomized subsampling. So in a lot of cases, bagging is quite nice. [NOISE] Okay?
- 1:11:08
- So I've talked a bit about ba- about bagging, uh, let's talk about decision trees plus bagging now.
- 1:11:23
- Okay. So you recall that decision trees are high [NOISE] variance,
- 1:11:35
- low bias okay? And this right here sort of explains why they're a pretty good fit for bagging.
- 1:11:43
- Okay? Because bagging what you're doing, is you're decreasing the variance of your models for a slight increase in bias.
- 1:11:49
- And since most of your error from your decision trees is coming from the high variance side of things,
- 1:11:54
- by sort of driving down that variance, you get a lot more benefit than for a, a model that would be on the reverse high bias and low variance.
- 1:12:03
- Okay? So, so this makes this like an ideal fit [NOISE] for bagging.
- 1:12:10
- [NOISE]
- 1:12:24
- Okay. [NOISE] So now, um, this is sort of decision trees plus bagging.
- 1:12:29
- I said that random forests are sort of a version of decision trees plus bagging. And so what I've described here is actually almost a random forest at this point.
- 1:12:38
- The one key point we're still missing is that random forests actually introduce even more randomization into each individual decision tree.
- 1:12:46
- And the idea behind that is that- as I had a question from before is this Rho,
- 1:12:51
- you can only drive it down so far through just pure bootstrapping. But if you can further decorrelate your different random variables,
- 1:12:58
- then you can drive down that variance even further, okay? Um, and so the idea there is that basically for- at each split for random forests,
- 1:13:18
- at each split, you consider only a fraction
- 1:13:29
- of your total features, right?
- 1:13:45
- So it's sort of like, for that ski example, maybe like for the first split, I only let it look at latitude, and then for the second split,
- 1:13:52
- I only let it look at, uh, the time of the year. [NOISE] And so this might seem a little bit unintuitive at first,
- 1:13:59
- but you can sort of get the intuition from two ways. One is that you're decreasing Rho and then the other one
- 1:14:11
- is you can think that- say you have a classification example, where you have one very strong predictor that gets you very good performance on its own.
- 1:14:19
- And regardless of what bootstrap sample you select, your model is probably gonna use that predictor as its first split.
- 1:14:24
- That's gonna cause all your models to be very highly correlated right at that first split, for example, and by instead forcing it to,
- 1:14:32
- to sample from different features. Instead, that's going to increase the, uh, or decrease the correlation between your models.
- 1:14:39
- And so it's all about decorrelating your models in this case. [NOISE] Okay.
- 1:14:52
- And that sort of brings to a close a lot of our discussion of bagging. Are there any questions regarding bagging?
- 1:15:00
- Okay. Now, I've covered bagging.
- 1:15:06
- Let's get a little bit into boosting. [NOISE] And I'll make this quick.
- 1:15:16
- But basically, whereas bagging we sort of saw in the intuition that
- 1:15:24
- we were decreasing variance, boosting is sort of actually more of the opposite where you're decreasing the bias of your models, okay?
- 1:15:31
- So- [NOISE]
- 1:15:43
- and also it- it's basically, um, more additive in, um, in how it's doing things.
- 1:15:49
- So versus- [NOISE] you'll recall that for bagging,
- 1:15:55
- you were taking the average of a number of variables. In boosting, what happens, you train one model and then you add that prediction into your ensemble.
- 1:16:02
- And then when you turn a new model, you just add that in as a prediction. And so- and that's a little bit handwavy right now.
- 1:16:07
- So let me actually make that clear through an example. [NOISE] So say you have a dataset, again, X1,
- 1:16:17
- X2, X2 and you have some data points, maybe some- that's actually- just call them pluses and minuses.
- 1:16:27
- So you have some more pluses here, and then maybe a couple of minuses and some pluses here, okay?
- 1:16:35
- And what you- say you're training a size one decision tree. So decision stumps is what we call them.
- 1:16:41
- And so you only get to ask one question at a time. And the reason behind this, just really quickly is that because you're decreasing bias
- 1:16:48
- by restricting your trees to be only depth 1, you basically are increasing
- 1:16:54
- their amount of bias and decreasing their amount of variance, which makes them a better fit for boosting kind of methods.
- 1:16:59
- And say that you come up with a, a decision boundary, okay? Say this one here, okay?
- 1:17:06
- And what you're gonna do is, on this side you predict positive, right? And on this side you predict negative.
- 1:17:11
- There's like a reasonable like line that you could draw here, but it's not perfect, right? You've made some mistakes. And in fact, what you can do is you can sort of identify these mistakes.
- 1:17:21
- Now, if we draw this in red, right? You've got- made these guys as mistakes.
- 1:17:26
- And what boosting does is basically it increases the weights of the mistakes you've made.
- 1:17:33
- And then for the next out- uh, decision stump that you train, it's now trained on this modified set.
- 1:17:39
- Which we could, let's just draw it over here.
- 1:17:45
- One. [NOISE] And so now you- these positives,
- 1:17:50
- I'll just draw them much bigger. You know, you've got big positives here and some small negatives, and some small positives,
- 1:17:57
- some big negatives here. And so now your model, to try and get these right,
- 1:18:03
- might pick a decision boundary like this, right? And this is also basically recursive in that each step, right?
- 1:18:10
- You're gonna be reweighting each of the examples based on how many of your previous ones have gotten it wrong or right in the past.
- 1:18:17
- [NOISE] And so basically what you're doing is you can sort of weight each one of these classifiers.
- 1:18:25
- You can determine [NOISE]
- 1:18:32
- for classifier Gm,
- 1:18:39
- a weight Alpha m, which is proportional to how many examples you got wrong or right.
- 1:18:49
- So a better classifier, you wanna give it more weight, um, and, uh, a bad classifier you wanna give it less weight proportional.
- 1:18:59
- And, uh, I think that the exact equation used in AdaBoost, for example,
- 1:19:04
- is just log of 1 minus the error of your nth model divided with basically log odds, okay?
- 1:19:14
- And then your total classifier is just F of- or let's just call it G of x again.
- 1:19:19
- G of x is just the sum over m of Alpha m,
- 1:19:28
- G of m, right? And then each G of m is trained
- 1:19:34
- on a weighted- on a reweighted,
- 1:19:47
- actually, reweighted training set.
- 1:19:56
- And so I've glossed over a lot of the details here in interest of time, but the specifics of an algorithm like this are- will be in the lecture notes.
- 1:20:05
- And this algorithm is actually known as AdaBoost. [NOISE] And basically through similar techniques,
- 1:20:13
- you can derive algorithms such as XGBoost or gradient boosting machines that also allow you to
- 1:20:20
- basically reweight the examples you're getting right or wrong in this sort of dynamic fashion and slowly adding them in this additive fashion to your composite model.
- 1:20:29
- [NOISE] And that about finishes it for today. Uh, thanks for coming. Um, yeah, a great rest of your week.